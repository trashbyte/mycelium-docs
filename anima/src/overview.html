{{1:Overview}}

{{2:Rationale}}

TODO

{{2:Terminology}}

<p><b>Persona</b>: a "Persona" in this document, when capitalized, refers to a consistent, cryptographically verifiable identity. This identity may be strongly linked to a real person or other real entity, or it may be anonymous. A person may have one or many Personas.</p>

<p><b>Endorsement</b>: an "Endorsement" in this document, when capitalized, refers to a cryptographic signature generated by another third-party Persona based on a public key, which is used to "endorse" the authenticity of the public key, i.e. supporting the claim that this key does in fact correspond to a private key owned by the alleged Persona. Endorsements, especially from people you personally trust, add veracity to authentication via public keys. Endorsements are similar to "keysigning" in OpenPGP.</p>

{{2:Persona Authentication}}

<p>The Persona authentication process begins with a LUCID URI as described in <a href="#2.2">Part 2.2</a>. These URIs will be attached to anything that one might feasibly want to verify the authorship of. The format of the URIs themselves is defined, but the way in which they are provided is not. They may be included in JSON data, appended in plain text after a message, or any other technique which makes the URI easily accessible.</p>

<p>Next, the full public key, identity proofs, and endorsements for the Persona must be located. Note that LUCID URIs are Uniform Resource <i>Identifiers</i>, not Uniform Resource <i>Locators</i>. The significance of this distinction lies in the fact that this specification does not define a canonical method for resolving LUCID URIs to Personas ("locating" them). It is intentionally left undefined and intended to be open-ended and implementation-specific, though other specifications for LUCID URI resolution may be created in the future.</p>

<p>When the canonical home of the Persona has been located, several resources are collected: the Persona's full public key, a list of ownership proofs (links to - or single proofs as found on - sites such as Keyoxide or Keybase), and a list of Endorsements for that public key. All of this information is stored locally by the client, along with notes about what Persona the key belongs to, for future authentication purposes. All keys found this way should always have at least one Endorsement, from the key owner themselves. This Endorsement obviously doesn't mean anything for the trustworthiness of the key, but it does provide a baseline level of cryptographic integrity.</p>

<p>Once the public key has been stored, any future messages that include an attached fingerprint matching the key can be cryptographically verified using that stored public key, allowing subsequent authentication based on the fingerprint alone.</p>

{{2:Web of Trust}}

<p>Anima is based on a decentralized trust model known as the "web of trust". The basic principle is that although you can't be expected to know everyone in the world personally, there can be a few people you trust, who have a few people they trust, who have a few people they trust, and so on, forming a giant "web of trust" that can provide some sense of the trustworthiness of a stranger based on who else trusts them, and how many trust-hops away from you they are in the web. Anima has a trust system similar to OpenPGP's but with more fine-grained trust distinctions and more amenable to numeric analysis of complex trust chains. The trust system is outlined in <a href="#4">Part 4</a>.</p>

{{2:Encryption for Confidentiality}}

<p>TODO - key exchange, communication via symmetric cipher</p>

{{2:Compliance}}

<p>When marked in small caps, the terms <mark>must</mark>, <mark>must not</mark>, <mark>required</mark>, <mark>should</mark>, <mark>should not</mark>, <mark>may</mark>, <mark>optional</mark>, <mark>recommended</mark>, and <mark>not recommended</mark> are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt" target="_blank">RFC 2119</a>. The small caps term <mark>not required</mark> is equivalent to the term <mark>optional</mark> as defined in RFC 2119.</p>