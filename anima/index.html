<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="style.css">
	<link rel="stylesheet" href="/fonts/NotoSans.css">
	<link rel="stylesheet" href="/fonts/FiraCode.css">
	<title>[[untitled spec]]</title>
</head>
<body>
	<div id="main">
		<h1 id="main-title">Anima Cryptographic Identity Protocol</h1>
		<aside>Note: this documentation is currently a work in progress</aside>
		<h2 id="toc-heading">Table of Contents</h2>
		<ul class="toc"><li class="depth-1"><a href="#1">1. Overview</a></li><li class="depth-2"><a href="#1.1">1.1. Rationale</a></li><li class="depth-2"><a href="#1.2">1.2. Terminology</a></li><li class="depth-2"><a href="#1.3">1.3. Persona Authentication</a></li><li class="depth-2"><a href="#1.4">1.4. Web of Trust</a></li><li class="depth-2"><a href="#1.5">1.5. Encryption for Confidentiality</a></li><li class="depth-2"><a href="#1.6">1.6. Compliance</a></li><li class="depth-1"><a href="#2">2. Keys and Fingerprints</a></li><li class="depth-2"><a href="#2.1">2.1. Fingerprints</a></li><li class="depth-2"><a href="#2.2">2.2. LUCID URIs</a></li><li class="depth-2"><a href="#2.3">2.3. Endorsements</a></li><li class="depth-1"><a href="#3">3. Message Data</a></li><li class="depth-2"><a href="#3.1">3.1. Data Types</a></li><li class="depth-2"><a href="#3.2">3.2. Endorsement Message</a></li><li class="depth-1"><a href="#4">4. Trust System</a></li><li class="depth-2"><a href="#4.1">4.1. Trust Levels</a></li><li class="depth-1"><a href="#5">5. Cipher Suite</a></li><li class="depth-2"><a href="#5.1">5.1. Hashing Algorithms</a></li><li class="depth-3"><a href="#5.1.1">5.1.1. Allowed Hashing Algorithms</a></li><li class="depth-3"><a href="#5.1.2">5.1.2. Disallowed Hashing Algorithms</a></li><li class="depth-3"><a href="#5.1.3">5.1.3. TBD</a></li><li class="depth-2"><a href="#5.2">5.2. Symmetric Ciphers</a></li><li class="depth-3"><a href="#5.2.1">5.2.1. Allowed Symmetric Ciphers</a></li><li class="depth-3"><a href="#5.2.2">5.2.2. Disallowed Symmetric Ciphers</a></li><li class="depth-2"><a href="#5.3">5.3. Asymmetric Ciphers</a></li><li class="depth-3"><a href="#5.3.1">5.3.1. Allowed Asymmetric Ciphers</a></li><li class="depth-3"><a href="#5.3.2">5.3.2. Disallowed Asymmetric Ciphers</a></li><li class="depth-2"><a href="#5.4">5.4. Compression Algorithms</a></li><li class="depth-3"><a href="#5.4.1">5.4.1. zlib</a></li><li class="depth-3"><a href="#5.4.2">5.4.2. brotli</a></li><li class="depth-3"><a href="#5.4.3">5.4.3. lzma</a></li><li class="depth-3"><a href="#5.4.4">5.4.4. zstd</a></li></ul>
		<h1 id="1">1. Overview</h1>

<h2 id="1.1">1.1. Rationale</h2>

TODO

<h2 id="1.2">1.2. Terminology</h2>

<p><b>Persona</b>: a "Persona" in this document, when capitalized, refers to a consistent, cryptographically verifiable identity. This identity may be strongly linked to a real person or other real entity, or it may be anonymous. A person may have one or many Personas.</p>

<p><b>Endorsement</b>: an "Endorsement" in this document, when capitalized, refers to a cryptographic signature generated by another third-party Persona based on a public key, which is used to "endorse" the authenticity of the public key, i.e. supporting the claim that this key does in fact correspond to a private key owned by the alleged Persona. Endorsements, especially from people you personally trust, add veracity to authentication via public keys. Endorsements are similar to "keysigning" in OpenPGP.</p>

<h2 id="1.3">1.3. Persona Authentication</h2>

<p>The Persona authentication process begins with a LUCID URI as described in <a href="#2.2">Part 2.2</a>. These URIs will be attached to anything that one might feasibly want to verify the authorship of. The format of the URIs themselves is defined, but the way in which they are provided is not. They may be included in JSON data, appended in plain text after a message, or any other technique which makes the URI easily accessible.</p>

<p>Next, the full public key, identity proofs, and endorsements for the Persona must be located. Note that LUCID URIs are Uniform Resource <i>Identifiers</i>, not Uniform Resource <i>Locators</i>. The significance of this distinction lies in the fact that this specification does not define a canonical method for resolving LUCID URIs to Personas ("locating" them). It is intentionally left undefined and intended to be open-ended and implementation-specific, though other specifications for LUCID URI resolution may be created in the future.</p>

<p>When the canonical home of the Persona has been located, several resources are collected: the Persona's full public key, a list of ownership proofs (links to - or single proofs as found on - sites such as Keyoxide or Keybase), and a list of Endorsements for that public key. All of this information is stored locally by the client, along with notes about what Persona the key belongs to, for future authentication purposes. All keys found this way should always have at least one Endorsement, from the key owner themselves. This Endorsement obviously doesn't mean anything for the trustworthiness of the key, but it does provide a baseline level of cryptographic integrity.</p>

<p>Once the public key has been stored, any future messages that include an attached fingerprint matching the key can be cryptographically verified using that stored public key, allowing subsequent authentication based on the fingerprint alone.</p>

<h2 id="1.4">1.4. Web of Trust</h2>

<p>Anima is based on a decentralized trust model known as the "web of trust". The basic principle is that although you can't be expected to know everyone in the world personally, there can be a few people you trust, who have a few people they trust, who have a few people they trust, and so on, forming a giant "web of trust" that can provide some sense of the trustworthiness of a stranger based on who else trusts them, and how many trust-hops away from you they are in the web. Anima has a trust system similar to OpenPGP's but with more fine-grained trust distinctions and more amenable to numeric analysis of complex trust chains. The trust system is outlined in <a href="#4">Part 4</a>.</p>

<h2 id="1.5">1.5. Encryption for Confidentiality</h2>

<p>TODO - key exchange, communication via symmetric cipher</p>

<h2 id="1.6">1.6. Compliance</h2>

<p>When marked in small caps, the terms <mark>must</mark>, <mark>must not</mark>, <mark>required</mark>, <mark>should</mark>, <mark>should not</mark>, <mark>may</mark>, <mark>optional</mark>, <mark>recommended</mark>, and <mark>not recommended</mark> are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt" target="_blank">RFC 2119</a>. The small caps term <mark>not required</mark> is equivalent to the term <mark>optional</mark> as defined in RFC 2119.</p>
		<h1 id="2">2. Keys and Fingerprints</h1>

<h2 id="2.1">2.1. Fingerprints</h2>

<p>Key fingerprints are compact identifiers that can be liberally attached to messages and media with minimal usage of bandwidth or storage. Fingerprints are calculated from a public key using SHA3-512/192, that is, hashed using the SHA-3 hashing algorithm with an output size of 512 bits, which is then truncated to 192 bits. These fingerprints are commonly represented by a string of 32 Base64 characters, e.g. <code>k79dnQ7BwEabPeqqXyZlvyEJ3exz4eVF</code>. These <mark>may</mark> be displayed to the user in groups of 4 for readability (such as <code>k79d nQ7B wEab Peqq XyZl vyEJ 3exz 4eVF</code>) but they <mark>must</mark> be stored and transmitted without any such padding. (TODO: is 512/192 actually stronger than 224/192 or simply 192?)</p>

<p>Fingerprints serve as a globally unique identifier for a Persona. They are resilient to collision or preimage attacks but <mark>must not</mark> be considered equivalent to a public key. Messages with <i>only</i> a fingerprint attached should not be trusted for anything important. Important messages <mark>should</mark> always contain a cryptographic signature alongside the fingerprint, so that the full public key matching the fingerprint can be used to properly verify the contents. Even in the event of a successful collision attack in the future, users who already have the fingerprint's original public key stored would be unaffected.</p>

<p>Malicious public keys generated with colliding fingerprints may try to claim that they are the correct Persona for the fingerprint, which could trick users who haven't received the original, genuine public key. This is not currently computationally feasible, but it could become so in the future. The only way to solve this problem is socially, i.e. by making it publically known that there is an impersonator with your fingerprint out there. A new keypair could be generated and endorsements for it received again, and then revoke the original key/fingerprint, which would alleviate the impersonator problem, but this is potentially a very difficult and time-consuming task and so cannot be considered an acceptable solution. In the event that fingerprints become easily compromised in the future, later versions of the protocol may use more secure fingerprints, and systems will need to be able to handle upgrading to these new fingerprints at that time.</p>

<p>In an abundance of caution, entire public keys could be attached to messages instead of fingerprints. With some ECC-based algorithms, the full public key is fairly short (an Ed25519 public key is 64 characters in Base64). However, this practice is currently <mark>not recommended</mark> unless viable attacks on the SHA3 hash are discovered.</p>

<h2 id="2.2">2.2. LUCID URIs</h2>

<p>The perferred identifier for a Persona is a Uniform Resource Identifier (URI) (as per <a href="https://www.rfc-editor.org/rfc/rfc3986" target="_blank">RFC 3986</a>) with a <code>lucid</code> scheme (not yet registered with IANA). LUCID stands for Lightweight Unique Cryptographic IDentifier.</p>

<p><code>lucid</code> URIs <mark>must</mark> be formatted as follows: <code class="nolig">lucid:<span class="red">&lt;version&gt;</span>:<span class="blue">&lt;fingerprint&gt;</span><span class="green">?&lt;query&gt;#&lt;fragment&gt;</span></code></p>

<p><code class="red">&lt;version&gt;</code> is a string starting with "v" followed by an integer representing the LUCID URI version. Currently, only version 1 exists, written as <code>v1</code>. The "v" is case-insensitive.</p>

<p><code class="blue">&lt;fingerprint&gt;</code> is a SHA3-512/192 fingerprint as described above, encoded in Base64.</p>

<p><code class="green">&lt;query&gt;</code> and <code class="green">&lt;fragment&gt;</code> are a query component and fragment identifier respectively, as defined in <a href="https://www.rfc-editor.org/rfc/rfc3986" target="_blank">RFC 3986</a>. They currently have no defined use, but may be used in the future for purposes such as supplying parameters to identity queries or identifying sub-resources. Compliant implementations <mark>must</mark> accept and be able to parse LUCID URIs with query strings or fragments, though currently they are <mark>not required</mark> to do anything with that data.</p>

<p>The <code>lucid:</code> scheme, <code class="red">&lt;version&gt;</code>, and <code class="blue">&lt;fingerprint&gt;</code> are <mark>required</mark> in a valid LUCID URI. <code class="green">&lt;query&gt;</code> and <code class="green">&lt;fragment&gt;</code> are <mark>optional</mark>. Examples of a valid LUCID URIs are:</p>

<ul>
	<li><code>lucid:<span class="red">v1</span>:<span class="blue">k79dnQ7BwEabPeqqXyZlvyEJ3exz4eVF</span></code></li>
	<li><code>lucid:<span class="red">v1</span>:<span class="blue">k79dnQ7BwEabPeqqXyZlvyEJ3exz4eVF</span><span class="green">?param=true</span></code></li>
	<li><code>lucid:<span class="red">V1</span>:<span class="blue">k79dnQ7BwEabPeqqXyZlvyEJ3exz4eVF</span><span class="green">#example</span></code></li>
	<li><code>LUCID:<span class="red">v1</span>:<span class="blue">k79dnQ7BwEabPeqqXyZlvyEJ3exz4eVF</span><span class="green">?param=3&another=%26%3A#example</span></code></li>
</ul>

<h2 id="2.3">2.3. Endorsements</h2>

<p>Version 1 (the current and only version) Endorsements consist of five pieces of information: the Endorsement algorithm version number, the fingerprint of the endorser, the trust level associated with the Endorsement, a timestamp indicating when the endorsement was made, and a cryptographic signature. The signature is generated from the concatenation of the following:

<ul>
	<li>the bytes of the target Persona's public key</li>
	<li>a single byte representing the version number</li>
	<li>a single signed byte representing the trust level assigned to the Endorsement (see <a href="#4.1">Trust Levels</a>)</li>
	<li>the bytes of the endorser's fingerprint</li>
	<li>the Endorsement timestamp, represented as a Unix epoch timestamp in seconds, as a 32-bit unsigned big-endian integer (four bytes).</li>
</ul>

<p>This stream of bytes is then signed using the endorser's private key, and the resulting signature is used for the Endorsement. Note that the type of public key used is irrelevant. As long as both the endorser and the verifier use the same byte stream, the result will be the same, regardless of the format or size of the public key. Future Endorsement versions are guaranteed to contain a version number, but all other fields may be different.</p>

<p>Security when obtaining the other Persona's original public key is crucial - all other verifications are based on this key. By contrast, security when issuing Endorsements is a non-issue, since they're generated cryptographically with your secret private key, the other Persona's public key (which should be cached locally), and the related Endorsement information, so intercepting them in transit provides no added value to an attacker. Cryptographically invalid Endorsement signatures are rejected, and if the attacker wants to issue their own Endorsement, they can already do that - the weight of that endorsement depends on their own trustworthiness.</p>
		<h1 id="3">3. Message Data</h1>

<h2 id="3.1">3.1. Data Types</h2>

<p class="data-type-def"><code class="field-type">Number</code></p>
<span>A numeric quantity. Any restrictions on the field (bounds, integers only, etc) will be in the field description.</span>
<p class="data-type-def"><code class="field-type">String</code></p>
<span>A string of UTF-8 characters.</span>
<p class="data-type-def"><code class="field-type">Base64</code></p>
<span>Raw byte data, encoded as a Base64 string.</span>
<p class="data-type-def"><code class="field-type">Timestamp</code></p>
<span>A date and time corresponding to an event. <mark>Must</mark> be a string in the specific <code>YYYY-MM-DDThh:mm:ssZ</code> format as defined by ISO 8601. Timestamps <mark>must</mark> always be in UTC, with the <code>Z</code> suffix.</span>
<p class="data-type-def"><code class="field-type">Array of T</code></p>
<span>A list of values of a certain type <code>T</code>. Arrays may be homogenous or heterogenous, and may or may not be empty.</span>
<p class="data-type-def"><code class="field-type">Object</code></p>
<span>A composite type consisting of a set of named fields and their values.</span>
<p class="data-type-def"><code class="field-type">HashAlgorithm</code></p>
<span>A supported hash algorithm, represented as a <code class="field-type">String</code>. <mark>Must</mark> be one of:</span>
<ul class="enum-list">
    <li class="enum-value"><code class="literal">"SHA2-512/256"</code></li>
    <li class="enum-value"><code class="literal">"SHA2-384"</code></li>
    <li class="enum-value"><code class="literal">"SHA3-256"</code></li>
    <li class="enum-value"><code class="literal">"SHA3-384"</code></li>
    <li class="enum-value"><code class="literal">"SHA3-512"</code></li>
    <li class="enum-value"><code class="literal">"BLAKE2s-256"</code></li>
    <li class="enum-value"><code class="literal">"BLAKE2b-384"</code></li>
    <li class="enum-value"><code class="literal">"BLAKE2b-512"</code></li>
</ul>
<span>The capitalizations shown are the preferred representation, but a <code class="field-type">HashAlgorithm</code> value is case-insensitive.</span>
<p class="data-type-def"><code class="field-type">CompressionAlgorithm</code></p>
<span>A supported compression algorithm, represented as a <code class="field-type">String</code>. <mark>Must</mark> be one of:</span>
<ul class="enum-list">
    <li class="enum-value"><code class="literal">"zlib"</code></li>
    <li class="enum-value"><code class="literal">"brotli"</code></li>
    <li class="enum-value"><code class="literal">"lzma"</code></li>
    <li class="enum-value"><code class="literal">"zstd"</code></li>
</ul>
<span>The capitalizations shown are the preferred representation, but a <code class="field-type">CompressionAlgorithm</code> value is case-insensitive.</span>
<p class="data-type-def"><code class="field-type">SymmetricCipher</code></p>
<span>A supported symmetric key cipher, represented as a <code class="field-type">String</code>. <mark>Must</mark> be one of:</span>
<ul class="enum-list">
    <li class="enum-value"><code class="literal">"AES-GCM-128"</code></li>
    <li class="enum-value"><code class="literal">"AES-CCM-128"</code></li>
    <li class="enum-value"><code class="literal">"ChaCha20-Poly1305"</code></li>
</ul>
<span>The capitalizations shown are the preferred representation, but a <code class="field-type">SymmetricCipher</code> value is case-insensitive.</span>
<p class="data-type-def"><code class="field-type">AsymmetricCipher</code></p>
<span>A supported asymmetric key cipher, represented as a <code class="field-type">String</code>. <mark>Must</mark> be one of:</span>
<ul class="enum-list">
    <li class="enum-value"><code class="literal">"RSA2048"</code></li>
    <li class="enum-value"><code class="literal">"RSA4096"</code></li>
    <li class="enum-value"><code class="literal">"Ed25519"</code></li>
    <li class="enum-value"><code class="literal">"Ed448"</code></li>
    <li class="enum-value"><code class="literal">"NISTp256"</code></li>
    <li class="enum-value"><code class="literal">"NISTp384"</code></li>
    <li class="enum-value"><code class="literal">"NISTp521"</code></li>
</ul>
<span>The capitalizations shown are the preferred representation, but a <code class="field-type">AsymmetricCipher</code> value is case-insensitive.</span>
<p class="data-type-def"><code class="field-type">MessageType</code></p>
<span>Denotes a type of message, represented as a <code class="field-type">String</code>. Valid options are:</span>
<ul class="enum-list">
    <li class="enum-value"><code class="literal">"SessionKey"</code><br><span class="desc">This message type contains an encrypted symmetric session key used for confidential data transmission.</span><br><span class="desc">Requires fields: <code class="field-name">sessionKey</code>.</span></li>
    <li class="enum-value"><code class="literal">"Signature"</code><br><span class="desc">This message type contains a signature corresponding to a <code class="field-type">SignatureType</code>.</span><br><span class="desc">Requires fields: <code class="field-name">signature</code>.</span></li>
    <li class="enum-value"><code class="literal">"Capabilities"</code><br><span class="desc">This message type contains information about the ciphers and algorithms supported by the sender.</span><br><span class="desc">Requires fields: <code class="field-name">capabilities</code>.</span></li>
</ul>
<span>The capitalizations shown are the preferred representation, but a <code class="field-type">MessageType</code> value is case-insensitive.</span>
<p class="data-type-def"><code class="field-type">SignatureType</code></p>
<span>Denotes a type of signature, represented as a <code class="field-type">String</code>. Valid options are:</span>
<ul class="enum-list">
    <li class="enum-value"><code class="literal">"BinaryDocumentSignature"</code><br><span class="desc">This means the signer owns it, created it, or certifies that it has not been modified.</span></li>
    <li class="enum-value"><code class="literal">"TextDocumentSignature"</code><br><span class="desc">Identical to BinaryDocumentSignature except that line endings are normalized to <CR><LF> before the signature is calculated.</span></li>
    <li class="enum-value"><code class="literal">"InlineSignature"</code><br><span class="desc">A signature verifying the BinaryData or TextData block present in the signature file. TextData is a JSON string which cannot include line breaks and escaped line endings are not normalized.</span></li>
    <li class="enum-value"><code class="literal">"IdentityCertificationSignature"</code><br><span class="desc">The issuer of this signature offers verification of the claim that the owner of the corresponding key is who they claim to be. Trust level is specified in <code class="field-name">trustLevel</code> field.</span></li>
    <li class="enum-value"><code class="literal">"KeyRevocationSignature"</code><br><span class="desc">The signature of a key to be revoked. A revoked key is not to be used. The signature is calculated directly on the key being revoked. Only revocation signatures made by the key being revoked should be considered valid revocation signatures.</span></li>
    <li class="enum-value"><code class="literal">"CertificationRevocationSignature"</code><br><span></span class="desc">This signature revokes an earlier IdentityCertificationSignature. It must be issued by the same key that issued the revoked signature. The signature is computed over the same data as the certificate that it revokes, and must have a later creation date than that certificate.</li>
</ul>
<span>The capitalizations shown are the preferred representation, but a <code class="field-type">SignatureType</code> value is case-insensitive.</span>

<h2 id="3.2">3.2. Endorsement Message</h2>

<p>The canonical form for an endorsement data packet is a JSON-compatible map with the following keys and fields:</p>

<pre><code>{
    <span class="field-name">"version"</span>: <span class="blue">1</span>,
    <span class="field-name">"trustLevel"</span>: <span class="literal">"Known"</span>,
    <span class="field-name">"signerFingerprint"</span>: <span class="literal">"k79dnQ7BwEabPeqqXyZlvyEJ3exz4eVF"</span>,
    <span class="field-name">"timestamp"</span>: <span class="literal">"2022-02-10T12:34:56Z"</span>,
    <span class="field-name">"signature"</span>: <span class="literal">"TODO"</span>
}</code></pre>

<p>These values are valid for a signer public key of <code>TODO</code> and a target public key of <code>TODO</code>. You can verify it yourself. Note that these values cannot be used to verify the endorsement as is. The Base64 strings will need to be converted to raw bytes and the trust level and timestamp into a numeric value. See <a href="#2.3">Part 2.3</a> for details on calculating Endorsement signatures.</p>

		<h1 id="4">4. Trust System</h1>

<h2 id="4.1">4.1. Trust Levels</h2>

<p>Every Persona is able to apply a "trust level" to every other Persona they know of by way of Endorsements. Each Endorsement is associated with a trust level ranging from explicitly distrusted, to neutral, to trusted, to a special level reserved for keys you own the private key for, and therefore don't need to "trust" ownership of at all.<p>

<p>Below is the list of trust levels and their associated descriptions. To the left are the numeric values for each level in parentheses, and in square brackets are possible letters or symbols used to represent them in user interfaces. These are only suggestions; implementations may use whatever abbreviated depiction they want so long as the full-word label is identical to those listed below. This system works best when assigned trust levels are honest and accurate, so give some thought to these before chosing one for someone.</p>

<ul id="trust-levels">
	<li><b>(-1) [<span class="icon">❌</span>][<span class="icon">X</span>] Untrustworthy</b>: Keys that have been revoked or that you have explicit reason to distrust.</li>
	<li><b>(0) [<span class="icon">❔</span>][<span class="icon">N</span>] Neutral</b>: Keys you have no supporting information for, but do not distrust.</li>
	<li><b>(1) [<span class="icon">➖</span>][<span class="icon">M</span>] Moderate</b>: Keys you have some reason to believe are legitimate.</li>
	<li><b>(2) [<span class="icon">⭕</span>][<span class="icon">K</span>] Known</b>: Keys of people you've personally known for a while. You trust them and you have good reason to believe that this key is theirs.</li>
	<li><b>(3) [<span class="icon">✔️</span>][<span class="icon">T</span>] Trusted</b>: Highly-trusted friends you've known for many years. You're very confident that this key is theirs.</li>
	<li><b>(4) [<span class="icon">⭐</span>][<span class="icon">V</span>] Verified</b>: Keys that have been directly verified by you in person.</li>
	<li><b>(5) [<span class="icon">🔑</span>][<span class="icon">S</span>] Self</b>: Keys you yourself own.</li>
</ul>

		<h1 id="5">5. Cipher Suite</h1>

<h2 id="5.1">5.1. Hashing Algorithms</h2>

<h3 id="5.1.1">5.1.1. Allowed Hashing Algorithms</h3>

<p>Note that public key fingerprints must always be generated with SHA3-512 truncated to 192 bits as defined in <a href="#2.1">Part 2.1</a>.</p>

<h4 id="5.1.1.1">SHA2-512/256</h4>

<p>SHA version 2 using an internal state size of 512 (8×64) bits, truncated to 256 bits. Thanks to the use of truncation, this method is resistant to length extension attacks.</p>

<h4 id="5.1.1.2">SHA2-384</h4>

<p>SHA version 2 using an internal state size of 512 (8×64) bits, truncated to 384 bits. Less resistant against length extension attacks than SHA2-512/256, but better collision resistance.</p>

<h4 id="5.1.1.3">SHA3-256</h4>

<p>SHA version 3 using an internal state size of 1600 (5×5×64) bits, with an output size of 256 bits. Equivalent to SHA2-512/256 for collision resistance, significantly stronger against length extension attacks but more expensive to compute than SHA2.</p>

<h4 id="5.1.1.4">SHA3-384</h4>

<p>SHA version 3 using an internal state size of 1600 (5×5×64) bits, with an output size of 384 bits. Stronger than SHA3-256 but more expensive to compute.</p>

<h4 id="5.1.1.5">SHA3-512</h4>

<p>SHA version 3 using an internal state size of 1600 (5×5×64) bits, with an output size of 512 bits. Stronger than SHA3-384 but more expensive to compute.</p>

<h4 id="5.1.1.6">BLAKE2s-256</h4>

<p>BLAKE2 with an internal state size of 256 bits and an output size of 256 bits. Significantly better worst-case collision resistance than SHA2 or SHA3, while being faster than both. SHA2/3 are still included as they are more thoroughly tested.</p>

<h4 id="5.1.1.7">BLAKE2b-384</h4>

<p>BLAKE2 with an internal state size of 512 bits and an output size of 384 bits. Stronger variant of BLAKE2s-256.</p>

<h4 id="5.1.1.8">BLAKE2b-512</h4>

<p>BLAKE2 with an internal state size of 512 bits and an output size of 512 bits. Stronger variant of BLAKE2b-384.</p>

<h3 id="5.1.2">5.1.2. Disallowed Hashing Algorithms</h3>

<h4 id="5.1.2.1">MD4 and MD5</h4>

<p>Cryptographically broken and collisions can be generated in seconds.</p>

<h4 id="5.1.2.2">MD2</h4>

<p>Less vulnerable than MD4 or MD5 but still not considered secure. MD2 support has been removed from  OpenSSL, GnuTLS, and NSS.</p>

<h4 id="5.1.2.3">SHA0 and SHA1</h4>

<p>Cryptographically broken; generating collisions for SHA-1 is computationally feasible, and takes only around an hour for SHA-0 on commodity hardware.</p>

<h4 id="5.1.2.4">SHA2-224, SHA2-256, and SHA2-512</h4>

<p>All are vulnerable against length extension attacks.</p>

<h4 id="5.1.2.5">SHA3-224</h4>

<p>Weaker than SHA3-256 but with nearly identical computation time.</p>

<h3 id="5.1.3">5.1.3. TBD</h3>

<h4 id="5.1.3.1">SHAKE128/SHAKE256</h4>
<h4 id="5.1.3.2">Whirlpool</h4>
<h4 id="5.1.3.3">RIPEMD-160</h4>

<h2 id="5.2">5.2. Symmetric Ciphers</h2>

<h3 id="5.2.1">5.2.1. Allowed Symmetric Ciphers</h3>

<h4 id="5.2.1.1">AES-GCM-128</h4>
<h4 id="5.2.1.2">AES-CCM-128</h4>
<h4 id="5.2.1.3">ChaCha20-Poly1305</h4>

<h3 id="5.2.2">5.2.2. Disallowed Symmetric Ciphers</h3>

<h2 id="5.3">5.3. Asymmetric Ciphers</h2>

<h3 id="5.3.1">5.3.1. Allowed Asymmetric Ciphers</h3>

<h4 id="5.3.1.1">RSA2048</h4>
<h4 id="5.3.1.2">RSA4096</h4>
<h4 id="5.3.1.3">Ed25519</h4>
<h4 id="5.3.1.4">Ed448</h4>
<h4 id="5.3.1.5">NISTp256</h4>
<h4 id="5.3.1.6">NISTp384</h4>
<h4 id="5.3.1.7">NISTp521</h4>

<h3 id="5.3.2">5.3.2. Disallowed Asymmetric Ciphers</h3>

<h2 id="5.4">5.4. Compression Algorithms</h2>

<h3 id="5.4.1">5.4.1. zlib</h3>

<p>(deflate + zlib wrapper)</p>

<h3 id="5.4.2">5.4.2. brotli</h3>
<h3 id="5.4.3">5.4.3. lzma</h3>
<h3 id="5.4.4">5.4.4. zstd</h3>
	</div>
</body>
</html>